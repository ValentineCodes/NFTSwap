{
  "language": "Solidity",
  "sources": {
    "contracts/NFTSwapPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n// import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./interfaces/INFTSwapPool.sol\";\nimport \"./interfaces/INFTSwapFactory.sol\";\n\n// import \"./libraries/PriceConverter.sol\";\n\nerror NFTSwapPool__ZeroAddress();\n\nerror NFTSwapPool__TokenPairNotFound();\n\nerror NFTSwapPool__ExchangeExists();\n\nerror NFTSwapPool__NonexistentExchange();\n\nerror NFTSwapPool__NotOwner();\n\nerror NFTSwapPool__AlreadyOwnedToken();\n\nerror NFTSwapPool__TransferFromFailed();\n\nerror NFTSwapPool__InvalidTrader();\n\nerror NFTSwapPool__InvalidTo();\n\nerror NFTSwapPool__PriceOutOfRange();\n\nerror NFTSwapPool__InvalidTokenReceiver();\n\nerror NFTSwapPool__InsufficientFee();\n\nerror NFTSwapFactory__FeeTransferFailed();\n\ncontract NFTSwapPool is INFTSwapPool {\n    // using PriceConverter for uint256;\n\n    uint256 private constant MINIMUM_FEE = 1 * 10**18; // in USD\n\n    address private immutable i_nft0;\n    address private immutable i_nft1;\n\n    INFTSwapFactory private immutable s_factory;\n    // AggregatorV3Interface private immutable s_priceFeed;\n\n    TokenIdPair[] private s_allPairs;\n\n    mapping(uint256 => mapping(uint256 => Exchange)) private s_exchange;\n\n    constructor(\n        address factory,\n        address nft0,\n        address nft1\n    ) {\n        s_factory = INFTSwapFactory(factory);\n        i_nft0 = nft0;\n        i_nft1 = nft1;\n        // s_priceFeed = AggregatorV3Interface(priceFeed);\n    }\n\n    function getNFTPair() external view override returns (address, address) {\n        return (i_nft0, i_nft1);\n    }\n\n    function getAllPairs()\n        external\n        view\n        override\n        returns (TokenIdPair[] memory)\n    {\n        return s_allPairs;\n    }\n\n    function getExchange(uint256 tokenId0, uint256 tokenId1)\n        external\n        view\n        override\n        returns (Exchange memory)\n    {\n        return s_exchange[tokenId0][tokenId1];\n    }\n\n    function _getOwnerOf(address nft, uint256 tokenId)\n        private\n        view\n        returns (address)\n    {\n        return IERC721(nft).ownerOf(tokenId);\n    }\n\n    function _createExchange(\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) private {\n        Exchange memory exchange = s_exchange[tokenId0][tokenId1];\n        (address nft0, address nft1) = (i_nft0, i_nft1);\n\n        if (exchange.owner != address(0)) revert NFTSwapPool__ExchangeExists();\n        if (trader == msg.sender || trader == nft0 || trader == nft1)\n            revert NFTSwapPool__InvalidTrader();\n\n        if (_getOwnerOf(nft1, tokenId1) == msg.sender)\n            revert NFTSwapPool__AlreadyOwnedToken();\n\n        IERC721(nft0).safeTransferFrom(msg.sender, address(this), tokenId0, \"\");\n\n        s_allPairs.push(TokenIdPair(tokenId0, tokenId1));\n        s_exchange[tokenId0][tokenId1] = Exchange(\n            msg.sender,\n            trader,\n            tokenId0,\n            tokenId1\n        );\n\n        // (bool success, ) = payable(s_factory.getFeeReceiver()).call{\n        //     value: msg.value\n        // }(\"\");\n\n        // if (!success) revert NFTSwapFactory__FeeTransferFailed();\n\n        emit ExchangeCreated(\n            nft0,\n            nft1,\n            msg.sender,\n            trader,\n            tokenId0,\n            tokenId1\n        );\n    }\n\n    // TO-DO: Handle price range\n    function createExchange(uint256 tokenId0, uint256 tokenId1)\n        external\n        override\n    {\n        // if (msg.value.toUSD(s_priceFeed) < 1)\n        //     revert NFTSwapPool__InsufficientFee();\n\n        _createExchange(address(0), tokenId0, tokenId1);\n    }\n\n    function createExchangeFor(\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external override {\n        if (trader == address(0)) revert NFTSwapPool__ZeroAddress();\n\n        // if (msg.value.toUSD(s_priceFeed) < 1)\n        //     revert NFTSwapPool__InsufficientFee();\n\n        _createExchange(trader, tokenId0, tokenId1);\n    }\n\n    function trade(uint256 tokenId0, uint256 tokenId1) external override {\n        Exchange memory exchange = s_exchange[tokenId0][tokenId1];\n        (address nft0, address nft1) = (i_nft0, i_nft1);\n\n        // if (msg.value.toUSD(s_priceFeed) < 1)\n        //     revert NFTSwapPool__InsufficientFee();\n\n        if (exchange.owner == address(0))\n            revert NFTSwapPool__NonexistentExchange();\n\n        if (msg.sender == exchange.owner) revert NFTSwapPool__InvalidTrader();\n\n        if (exchange.trader != address(0) && msg.sender != exchange.trader)\n            revert NFTSwapPool__InvalidTokenReceiver();\n\n        IERC721(nft0).safeTransferFrom(address(this), msg.sender, tokenId0, \"\");\n        IERC721(nft1).safeTransferFrom(\n            msg.sender,\n            exchange.owner,\n            tokenId1,\n            \"\"\n        );\n\n        if (\n            _getOwnerOf(nft0, tokenId0) != msg.sender &&\n            _getOwnerOf(nft1, tokenId1) != exchange.owner\n        ) revert NFTSwapPool__TransferFromFailed();\n\n        // (bool success, ) = payable(s_factory.getFeeReceiver()).call{\n        //     value: msg.value\n        // }(\"\");\n\n        // if (!success) revert NFTSwapFactory__FeeTransferFailed();\n\n        delete s_exchange[tokenId0][tokenId1];\n\n        emit Trade(nft0, nft1, exchange.owner, msg.sender, tokenId0, tokenId1);\n    }\n\n    function updateExchangeOwner(\n        address newOwner,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external override {\n        if (newOwner == address(0)) revert NFTSwapPool__ZeroAddress();\n\n        Exchange memory exchange = s_exchange[tokenId0][tokenId1];\n\n        if (msg.sender != exchange.owner) revert NFTSwapPool__NotOwner();\n\n        s_exchange[tokenId0][tokenId1] = Exchange(\n            newOwner,\n            exchange.trader,\n            exchange.tokenId0,\n            exchange.tokenId1\n        );\n\n        emit ExchangeUpdated(\n            i_nft0,\n            i_nft1,\n            newOwner,\n            exchange.trader,\n            exchange.tokenId0,\n            exchange.tokenId1\n        );\n    }\n\n    function updateExchangeTrader(\n        address newTrader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external override {\n        Exchange memory exchange = s_exchange[tokenId0][tokenId1];\n\n        if (msg.sender != exchange.owner) revert NFTSwapPool__NotOwner();\n        if (newTrader == exchange.owner) revert NFTSwapPool__InvalidTrader();\n\n        s_exchange[tokenId0][tokenId1] = Exchange(\n            exchange.owner,\n            newTrader,\n            exchange.tokenId0,\n            exchange.tokenId1\n        );\n\n        emit ExchangeUpdated(\n            i_nft0,\n            i_nft1,\n            exchange.owner,\n            newTrader,\n            exchange.tokenId0,\n            exchange.tokenId1\n        );\n    }\n\n    function cancelExchange(\n        uint256 tokenId0,\n        uint256 tokenId1,\n        address to\n    ) external override {\n        Exchange memory exchange = s_exchange[tokenId0][tokenId1];\n        (address nft0, address nft1) = (i_nft0, i_nft1);\n\n        if (msg.sender != exchange.owner) revert NFTSwapPool__NotOwner();\n        if (to == address(0) || to == nft0 || to == nft1)\n            revert NFTSwapPool__InvalidTo();\n\n        IERC721(nft0).safeTransferFrom(address(this), to, tokenId0, \"\");\n\n        delete s_exchange[tokenId0][tokenId1];\n\n        emit ExchangeCancelled(\n            nft0,\n            nft1,\n            exchange.owner,\n            exchange.trader,\n            to,\n            tokenId0,\n            tokenId1\n        );\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "contracts/interfaces/INFTSwapPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\ninterface INFTSwapPool {\n    event ExchangeCreated(\n        address nft0,\n        address nft1,\n        address owner,\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    event ExchangeUpdated(\n        address nft0,\n        address nft1,\n        address owner,\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    event ExchangeCancelled(\n        address nft0,\n        address nft1,\n        address owner,\n        address trader,\n        address receiver,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    event Trade(\n        address nft0,\n        address nft1,\n        address owner,\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    struct TokenIdPair {\n        uint256 tokenId0;\n        uint256 tokenId1;\n    }\n\n    struct Exchange {\n        address owner;\n        address trader;\n        uint256 tokenId0;\n        uint256 tokenId1;\n    }\n\n    function getNFTPair() external view returns (address, address);\n\n    function getAllPairs() external view returns (TokenIdPair[] memory);\n\n    function getExchange(uint256 tokenId0, uint256 tokenId1)\n        external\n        view\n        returns (Exchange memory);\n\n    function createExchange(uint256 token0Id, uint256 token1Id) external;\n\n    function createExchangeFor(\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external;\n\n    function trade(uint256 tokenId0, uint256 tokenId1) external;\n\n    function updateExchangeOwner(\n        address newOwner,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external;\n\n    function updateExchangeTrader(\n        address newTrader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external;\n\n    function cancelExchange(\n        uint256 tokenId0,\n        uint256 tokenId1,\n        address to\n    ) external;\n}\n"
    },
    "contracts/interfaces/INFTSwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\ninterface INFTSwapFactory {\n    event PoolCreated(address token0, address token1, address pool);\n\n    function getFeeReceiver() external view returns (address);\n\n    function getFeeReceiverSetter() external view returns (address);\n\n    function getAllPools() external view returns (address[] memory);\n\n    function getPool(address token0, address token1)\n        external\n        view\n        returns (address);\n\n    function createPool(address tokenA, address tokenB)\n        external\n        returns (address pool);\n\n    function setFeeReceiver(address _feeReceiver) external;\n\n    function setFeeReceiverSetter(address _feeReceiverSetter) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/NFTSwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"./interfaces/INFTSwapFactory.sol\";\nimport \"./interfaces/INFTSwapPool.sol\";\nimport \"./NFTSwapPool.sol\";\nimport \"./NoDelegateCall.sol\";\n\nerror NFTSwapFactory__NotFeeSetter();\n\nerror NFTSwapFactory__ZeroAddress();\n\nerror NFTSwapFactory__PoolAlreadyExists();\n\ncontract NFTSwapFactory is INFTSwapFactory, NoDelegateCall {\n    address private s_feeReceiver;\n\n    address private s_feeReceiverSetter;\n\n    address[] private s_allPools;\n\n    mapping(address => mapping(address => address)) private s_pool;\n\n    constructor() {\n        s_feeReceiver = msg.sender;\n        s_feeReceiverSetter = msg.sender;\n    }\n\n    modifier onlyFeeReceiverSetter() {\n        if (msg.sender != s_feeReceiverSetter)\n            revert NFTSwapFactory__NotFeeSetter();\n        _;\n    }\n\n    function getFeeReceiver() external view override returns (address) {\n        return s_feeReceiver;\n    }\n\n    function getFeeReceiverSetter() external view override returns (address) {\n        return s_feeReceiverSetter;\n    }\n\n    function getAllPools() external view override returns (address[] memory) {\n        return s_allPools;\n    }\n\n    function getPool(address nft0, address nft1)\n        external\n        view\n        override\n        returns (address)\n    {\n        return s_pool[nft0][nft1];\n    }\n\n    function _sortNFTs(address nftA, address nftB)\n        internal\n        pure\n        returns (address nft0, address nft1)\n    {\n        (nft0, nft1) = nftA < nftB ? (nftA, nftB) : (nftB, nftA);\n    }\n\n    function createPool(address nftA, address nftB)\n        external\n        override\n        noDelegateCall\n        returns (address pool)\n    {\n        (address nft0, address nft1) = _sortNFTs(nftA, nftB);\n\n        if (nft0 == address(0)) revert NFTSwapFactory__ZeroAddress();\n\n        if (s_pool[nft0][nft1] != address(0))\n            revert NFTSwapFactory__PoolAlreadyExists();\n\n        // deploy pool contract\n        pool = address(\n            new NFTSwapPool{\n                salt: keccak256(abi.encode(address(this), nft0, nft1))\n            }(address(this), nft0, nft1)\n        );\n\n        s_allPools.push(pool);\n        s_pool[nft0][nft1] = pool;\n\n        if (nft0 != nft1) {\n            s_pool[nft1][nft0] = pool;\n        }\n\n        emit PoolCreated(nft0, nft1, pool);\n\n        return pool;\n    }\n\n    function setFeeReceiver(address feeReceiver)\n        external\n        override\n        onlyFeeReceiverSetter\n    {\n        s_feeReceiver = feeReceiver;\n    }\n\n    function setFeeReceiverSetter(address feeReceiverSetter)\n        external\n        override\n        onlyFeeReceiverSetter\n    {\n        s_feeReceiverSetter = feeReceiverSetter;\n    }\n}\n"
    },
    "contracts/NoDelegateCall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.7;\n\n/// @title Prevents delegatecall to a contract\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract\nabstract contract NoDelegateCall {\n    /// @dev The original address of this contract\n    address private immutable original;\n\n    constructor() {\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\n        // In other words, this variable won't change when it's checked at runtime.\n        original = address(this);\n    }\n\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\n    function checkNotDelegateCall() private view {\n        require(address(this) == original);\n    }\n\n    /// @notice Prevents delegatecall into the modified method\n    modifier noDelegateCall() {\n        checkNotDelegateCall();\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}