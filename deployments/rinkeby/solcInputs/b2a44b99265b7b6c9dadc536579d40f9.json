{
  "language": "Solidity",
  "sources": {
    "contracts/NFTSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"./interfaces/INFTSwap.sol\";\n\nerror NFTSwap__ZeroAddress();\n\nerror NFTSwap__ExchangeExists();\n\nerror NFTSwap__NonexistentExchange();\n\nerror NFTSwap__NotOwner();\n\nerror NFTSwap__AlreadyOwnedToken();\n\nerror NFTSwap__TransferFromFailed();\n\nerror NFTSwap__InvalidTrader();\n\nerror NFTSwap__InvalidRecipient();\n\nerror NFTSwap__InvalidTokenReceiver();\n\nerror NFTSwap__Locked();\n\ncontract NFTSwap is INFTSwap {\n    uint256 private unlocked = 1;\n\n    Exchange[] private s_allExchanges;\n\n    mapping(address => mapping(uint256 => mapping(address => mapping(uint256 => Exchange))))\n        private s_exchange;\n\n    modifier lock() {\n        if (unlocked == 0) revert NFTSwap__Locked();\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getAllExchanges()\n        external\n        view\n        override\n        returns (Exchange[] memory)\n    {\n        return s_allExchanges;\n    }\n\n    function getExchange(\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external view override returns (Exchange memory) {\n        return s_exchange[nft0][tokenId0][nft1][tokenId1];\n    }\n\n    function _getOwnerOf(address nft, uint256 tokenId)\n        private\n        view\n        returns (address)\n    {\n        return IERC721(nft).ownerOf(tokenId);\n    }\n\n    function _createExchange(\n        address trader,\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) private {\n        Exchange memory exchange = s_exchange[nft0][tokenId0][nft1][tokenId1];\n        (nft0, nft1) = nft0 < nft1 ? (nft0, nft1) : (nft1, nft0);\n\n        if (nft0 == address(0)) revert NFTSwap__ZeroAddress();\n        if (exchange.owner != address(0)) revert NFTSwap__ExchangeExists();\n        if (_getOwnerOf(nft1, tokenId1) == msg.sender)\n            revert NFTSwap__AlreadyOwnedToken();\n\n        IERC721(nft0).safeTransferFrom(msg.sender, address(this), tokenId0, \"\");\n\n        s_allExchanges.push(\n            Exchange(msg.sender, trader, nft0, nft1, tokenId0, tokenId1)\n        );\n        s_exchange[nft0][tokenId0][nft1][tokenId1] = Exchange(\n            msg.sender,\n            trader,\n            nft0,\n            nft1,\n            tokenId0,\n            tokenId1\n        );\n\n        emit ExchangeCreated(\n            nft0,\n            nft1,\n            msg.sender,\n            trader,\n            tokenId0,\n            tokenId1\n        );\n    }\n\n    function createExchange(\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external override {\n        _createExchange(address(0), nft0, nft1, tokenId0, tokenId1);\n    }\n\n    function createExchangeFor(\n        address trader,\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external override {\n        if (trader == address(0)) revert NFTSwap__ZeroAddress();\n        if (trader == msg.sender || trader == nft0 || trader == nft1)\n            revert NFTSwap__InvalidTrader();\n\n        _createExchange(trader, nft0, nft1, tokenId0, tokenId1);\n    }\n\n    function trade(\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external override lock {\n        Exchange memory exchange = s_exchange[nft0][tokenId0][nft1][tokenId1];\n\n        if (exchange.owner == address(0)) revert NFTSwap__NonexistentExchange();\n        if (msg.sender == exchange.owner) revert NFTSwap__InvalidTrader();\n        if (exchange.trader != address(0) && msg.sender != exchange.trader)\n            revert NFTSwap__InvalidTokenReceiver();\n\n        IERC721(nft0).safeTransferFrom(address(this), msg.sender, tokenId0, \"\");\n        IERC721(nft1).safeTransferFrom(\n            msg.sender,\n            exchange.owner,\n            tokenId1,\n            \"\"\n        );\n\n        if (\n            _getOwnerOf(nft0, tokenId0) != msg.sender &&\n            _getOwnerOf(nft1, tokenId1) != exchange.owner\n        ) revert NFTSwap__TransferFromFailed();\n\n        delete s_exchange[nft0][tokenId0][nft1][tokenId1];\n\n        emit Trade(nft0, nft1, exchange.owner, msg.sender, tokenId0, tokenId1);\n    }\n\n    function updateExchangeOwner(\n        address newOwner,\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external override {\n        if (newOwner == address(0)) revert NFTSwap__ZeroAddress();\n\n        Exchange memory exchange = s_exchange[nft0][tokenId0][nft1][tokenId1];\n\n        if (msg.sender != exchange.owner) revert NFTSwap__NotOwner();\n\n        s_exchange[nft0][tokenId0][nft1][tokenId1].owner = newOwner;\n\n        emit ExchangeOwnerUpdated(\n            nft0,\n            nft1,\n            newOwner,\n            exchange.trader,\n            exchange.tokenId0,\n            exchange.tokenId1\n        );\n    }\n\n    function updateExchangeTrader(\n        address newTrader,\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external override {\n        Exchange memory exchange = s_exchange[nft0][tokenId0][nft1][tokenId1];\n\n        if (msg.sender != exchange.owner) revert NFTSwap__NotOwner();\n        if (newTrader == exchange.owner) revert NFTSwap__InvalidTrader();\n\n        s_exchange[nft0][tokenId0][nft1][tokenId1].trader = newTrader;\n\n        emit ExchangeTraderUpdated(\n            nft0,\n            nft1,\n            exchange.owner,\n            newTrader,\n            exchange.tokenId0,\n            exchange.tokenId1\n        );\n    }\n\n    function cancelExchange(\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1,\n        address recipient\n    ) external override {\n        Exchange memory exchange = s_exchange[nft0][tokenId0][nft1][tokenId1];\n\n        if (msg.sender != exchange.owner) revert NFTSwap__NotOwner();\n        if (recipient == address(0) || recipient == nft0 || recipient == nft1)\n            revert NFTSwap__InvalidRecipient();\n\n        IERC721(nft0).safeTransferFrom(address(this), recipient, tokenId0, \"\");\n\n        delete s_exchange[nft0][tokenId0][nft1][tokenId1];\n\n        emit ExchangeCancelled(\n            nft0,\n            nft1,\n            exchange.owner,\n            exchange.trader,\n            recipient,\n            tokenId0,\n            tokenId1\n        );\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "contracts/interfaces/INFTSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\n/// @title The NFTSwap interface\n/// @notice Manage exchanges and trades\ninterface INFTSwap {\n    /// @notice Emitted when an exchanged is created\n    /// @param nft0 The address of the first NFT\n    /// @param nft1 The address of the second NFT\n    /// @param owner The address of the exchange owner. Owner initialized as the exchange creator\n    /// @param trader The address of the exchange trader. Trader is the zero address if emitted from createExchange()\n    /// @param tokenId0 The token id of {nft0} to be exchanged by the owner\n    /// @param tokenId1 The token id of {nft1} to be received from trades\n    event ExchangeCreated(\n        address nft0,\n        address nft1,\n        address owner,\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    /// @notice Emitted when an exchanged owner is updated\n    /// @param nft0 The address of the first NFT\n    /// @param nft1 The address of the second NFT\n    /// @param newOwner The address of the new exchange owner\n    /// @param trader The address of the exchange trader\n    /// @param tokenId0 The token id of {nft0} to be exchanged by the owner\n    /// @param tokenId1 The token id of {nft1} to be received from trades\n    event ExchangeOwnerUpdated(\n        address nft0,\n        address nft1,\n        address newOwner,\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    /// @notice Emitted when an exchanged trader is updated\n    /// @param nft0 The address of the first NFT\n    /// @param nft1 The address of the second NFT\n    /// @param owner The address of the exchange owner\n    /// @param newTrader The address of the new exchange trader\n    /// @param tokenId0 The token id of {nft0} to be exchanged by the owner\n    /// @param tokenId1 The token id of {nft1} to be received from trades\n    event ExchangeTraderUpdated(\n        address nft0,\n        address nft1,\n        address owner,\n        address newTrader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    /// @notice Emitted when an exchange is cancelled\n    /// @param nft0 The address of the first NFT\n    /// @param nft1 The address of the second NFT\n    /// @param owner The address of the exchange owner\n    /// @param trader The address of the exchange trader\n    /// @param receiver The NFT receiver\n    /// @param tokenId0 The token id of {nft0} to be exchanged by the owner\n    /// @param tokenId1 The token id of {nft1} to be received from trades\n    event ExchangeCancelled(\n        address nft0,\n        address nft1,\n        address owner,\n        address trader,\n        address receiver,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    /// @notice Emitted when a trade occurs\n    /// @param nft0 The address of the first NFT\n    /// @param nft1 The address of the second NFT\n    /// @param owner The address of the exchange owner\n    /// @param trader The address of the trader\n    /// @param tokenId0 The token id of {nft0} received\n    /// @param tokenId1 The token id of {nft1} traded\n    event Trade(\n        address nft0,\n        address nft1,\n        address owner,\n        address trader,\n        uint256 tokenId0,\n        uint256 tokenId1\n    );\n\n    /// @notice Data model for exchanges\n    /// @dev tokenId0 and tokenId1 must be in order\n    /// @param owner Address of exchange owner\n    /// @param trader Address of trader. Can be set to zero address to allow all traders\n    /// @param nft0 Address of the NFT to be exchanged\n    /// @param nft1 Address of the requested NFT\n    /// @param tokenId0 The token id of {nft0} to be traded by exchange owner\n    /// @param tokenId1 The token id of {nft1} to be received by exchange owner\n    struct Exchange {\n        address owner;\n        address trader;\n        address nft0;\n        address nft1;\n        uint256 tokenId0;\n        uint256 tokenId1;\n    }\n\n    /// @notice Retrieves all token id pairs\n    /// @return Array of exchanges\n    function getAllExchanges() external view returns (Exchange[] memory);\n\n    /// @notice Retreives exchange data of token id pairs\n    /// @dev tokenId0 and tokenId1 must be in order\n    /// @param nft0 Address of the NFT to be traded by the exchange owner\n    /// @param nft1 Address of the NFT requested by the exchange owner\n    /// @param tokenId0 Token id of {nft0} to be traded by exchange owner\n    /// @param tokenId1 Token id of {nft1} requested by the exchange owner\n    /// @return Exchange data (see Exchange struct for data model)\n    function getExchange(\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external view returns (Exchange memory);\n\n    /// @notice Creates an exchange with tokenId0 for tokenId1 that can be traded by anyone\n    /// @dev tokenId0 and tokenId1 must be in order\n    /// @param nft0 Address of the NFT to be traded by the exchange owner\n    /// @param nft1 Address of the NFT requested by the exchange owner\n    /// @param tokenId0 Token id of {nft0} to be traded by the exchange owner\n    /// @param tokenId1 Token id of {nft1} requested by the exchange owner\n    function createExchange(\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external;\n\n    /// @notice Creates an exchange with tokenId0 for tokenId1 that can be traded by a specific trader\n    /// @dev tokenId0 and tokenId1 must be in order\n    /// @param trader Address of trader of the token requested\n    /// @param nft0 Address of the NFT to be traded by the exchange owner\n    /// @param nft1 Address of the NFT requested by the exchange owner\n    /// @param tokenId0 Token id of {nft0} to be traded by the exchange owner\n    /// @param tokenId1 Token id of {nft1} requested by the exchange owner\n    function createExchangeFor(\n        address trader,\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external;\n\n    /// @notice Trades tokenId1 for tokenId0\n    /// @dev tokenId0 and tokenId1 must be in order\n    /// @param nft0 Address of the NFT to be received by trader\n    /// @param nft1 Address of the NFT requested by the exchange owner\n    /// @param tokenId0 Token id of {nft0} to be received by trader\n    /// @param tokenId1 Token id of {nft1} requested by the exchange owner\n    function trade(\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external;\n\n    /// @notice Updates exchange owner\n    /// @dev tokenId0 and tokenId1 must be in order\n    /// @param newOwner Address of the new owner\n    /// @param nft0 Address of the NFT to be traded by the exchange owner\n    /// @param nft1 Address of the NFT requested by the exchange owner\n    /// @param tokenId0 Token id of {nft0} to be traded by the exchange owner\n    /// @param tokenId1 Token id of {nft1} requested by the exchange owner\n    function updateExchangeOwner(\n        address newOwner,\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external;\n\n    /// @notice Updates exchange trader\n    /// @dev tokenId0 and tokenId1 must be in order\n    /// @param newTrader Address of the new trader. Can be set to the zero address to allow all traders to trade\n    /// @param nft0 Address of the NFT to be traded by the exchange owner\n    /// @param nft1 Address of the NFT requested by the exchange owner\n    /// @param tokenId0 Token id of {nft0} to be traded by the exchange owner\n    /// @param tokenId1 Token id of {nft1} requested by the exchange owner\n    function updateExchangeTrader(\n        address newTrader,\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1\n    ) external;\n\n    /// @notice Cancels exchange and sends tokenId0 to {to}\n    /// @dev tokenId0 and tokenId1 must be in order\n    /// @param nft0 Address of the NFT to be traded by the exchange owner\n    /// @param nft1 Address of the NFT requested by the exchange owner\n    /// @param tokenId0 Token id of {nft0}\n    /// @param tokenId1 Token id of {nft1}\n    /// @param recipient Address of the receiver of tokenId0\n    function cancelExchange(\n        address nft0,\n        address nft1,\n        uint256 tokenId0,\n        uint256 tokenId1,\n        address recipient\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}